// Generated by CoffeeScript 1.8.0
(function() {
  var Universe;

  Universe = (function() {
    function Universe($container) {
      this.$container = $container;
      this.defaultNodeDepth = 8;
      this.defaultLayerWidth = 1600;
      this.defaultLayerHeight = 900;
      this.margin = 150;
      this.layers = [];
      this.sceneWidth = this.$container.width();
      this.sceneHeight = this.$container.height();
      this.ballAnimationQueue = [];
      this.initThree();
      this.initScene();
      this.initCamera();
      this.initLight();
      this.initSkybox();
      this.enableScrollWheelZoom();
      this.resize();
      this.animate();
    }

    Universe.prototype.converPosition = function(graphWidth, graphHeight, o) {
      var fn1, fn2, item, item1, offsetX, offsetY, r, r1, r2, self, _i, _j, _len, _len1, _ref, _ref1, _results;
      self = this;
      offsetX = 0;
      offsetY = 0;
      if (graphWidth >= self.defaultLayerWidth && graphHeight <= self.defaultLayerHeight) {
        r = self.defaultLayerWidth / graphWidth;
        offsetY = (self.defaultLayerHeight - graphHeight * r) / 2;
      } else if (graphHeight >= self.defaultLayerHeight && graphWidth <= self.defaultLayerWidth) {
        r = self.defaultLayerHeight / graphHeight;
        offsetX = (self.defaultLayerWidth - graphWidth * r) / 2;
      } else if (graphHeight <= self.defaultLayerHeight && graphWidth <= self.defaultLayerWidth) {
        r1 = self.defaultLayerHeight / graphHeight;
        r2 = self.defaultLayerWidth / graphWidth;
        if (r1 < r2) {
          r = r1;
          offsetX = (self.defaultLayerWidth - graphWidth * r) / 2;
        } else {
          r = r2;
          offsetY = (self.defaultLayerHeight - graphHeight * r) / 2;
        }
      } else if (graphHeight >= self.defaultLayerHeight && graphWidth >= self.defaultLayerWidth) {
        r1 = self.defaultLayerHeight / graphHeight;
        r2 = self.defaultLayerWidth / graphWidth;
        if (r1 > r2) {
          r = r1;
          offsetX = (self.defaultLayerWidth - graphWidth * r) / 2;
        } else {
          r = r2;
          offsetY = (self.defaultLayerHeight - graphHeight * r) / 2;
        }
      }
      if (o.nodes) {
        fn1 = function(info) {
          info.x = info.x * r + offsetX;
          return info.y = info.y * r + offsetY;
        };
        _ref = o.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          fn1(item);
        }
      }
      if (o.edges) {
        fn2 = function(info) {
          info.x = info.x * r + offsetX;
          return info.y = info.y * r + offsetY;
        };
        _ref1 = o.edges;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          item1 = _ref1[_j];
          _results.push((function() {
            var _k, _len2, _ref2, _results1;
            _ref2 = item1.points;
            _results1 = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              item = _ref2[_k];
              _results1.push(fn2(item));
            }
            return _results1;
          })());
        }
        return _results;
      }
    };

    Universe.prototype.drawNode = function(layer, data) {
      var fn1, item, self, _i, _len, _results;
      self = this;
      layer.node = {};
      fn1 = function(info) {
        var action, loaded, onProgress;
        onProgress = function(xhr) {
          var percentComplete;
          if (xhr.lengthComputable) {
            return percentComplete = xhr.loaded / xhr.total * 100;
          }
        };
        loaded = function(object) {
          object.position.set(info.x - self.defaultLayerWidth / 2 + info.width / 2, info.y - self.defaultLayerHeight / 2 + info.height / 2, self.defaultNodeDepth / 2 * -1);
          object.rotation.x = Math.PI / 2 * -1;
          object.scale.x = info.width;
          object.scale.y = info.height;
          object.scale.z = info.width;
          layer.node[info.id] = {
            info: info,
            cube: object
          };
          return layer.plane.add(object);
        };
        action = function(resource) {
          var loader;
          loader = new THREE.OBJMTLLoader();
          return loader.load(resource.obj, resource.mtl, loaded, onProgress);
        };
        console.log(info.img);
        return $.ajax({
          type: "get",
          url: self.getResource(info.img).obj,
          success: function() {
            return action(self.getResource(info.img));
          },
          error: function() {
            return action(self.getResource());
          },
          dataType: "text"
        });
      };
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        _results.push(fn1(item));
      }
      return _results;
    };

    Universe.prototype.getResource = function(url) {
      var arr, name;
      if (url) {
        arr = url.split("/");
        name = arr.pop();
        name = name.substring(0, name.lastIndexOf("."));
      } else {
        name = "LV";
      }
      return {
        obj: "../resource/3d/" + encodeURIComponent(name) + ".obj",
        mtl: "../resource/3d/" + encodeURIComponent(name) + ".mtl"
      };
    };

    Universe.prototype.drawLine = function(layer, points) {
      var fn, item, self, _i, _len, _results;
      self = this;
      if (points) {
        fn = function(item) {
          var cfn, citem, geometry, line, material, _i, _len, _ref;
          material = new THREE.LineBasicMaterial({
            color: 0x0000FF
          });
          geometry = new THREE.Geometry();
          cfn = function(o) {
            return geometry.vertices.push(new THREE.Vector3(o.x - self.defaultLayerWidth / 2, o.y - self.defaultLayerHeight / 2, -4));
          };
          _ref = item.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            citem = _ref[_i];
            cfn(citem);
          }
          line = new THREE.Line(geometry, material);
          return layer.add(line);
        };
        _results = [];
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          item = points[_i];
          _results.push(fn(item));
        }
        return _results;
      }
    };

    Universe.prototype.drawNodeTexture = function(layer, info) {
      var materialArray, materialFront, materialSide, o, self, textGeom, textHeight, textMaterial, textMesh, textWidth;
      self = this;
      o = layer.node[info.id].cube.position;
      materialFront = new THREE.MeshBasicMaterial({
        color: 0x348EF0
      });
      materialSide = new THREE.MeshBasicMaterial({
        color: 0x666666
      });
      materialArray = [materialFront, materialSide];
      textGeom = new THREE.TextGeometry(info.name, {
        size: 15,
        height: 1,
        curveSegments: 1,
        font: "lisu",
        weight: "normal",
        style: "normal",
        extrudeMaterial: 0
      });
      textMaterial = new THREE.MeshFaceMaterial(materialArray);
      textMesh = new THREE.Mesh(textGeom, textMaterial);
      textGeom.computeBoundingBox();
      textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
      textHeight = textGeom.boundingBox.max.y - textGeom.boundingBox.min.y;
      textMesh.rotation.x = Math.PI * -1;
      textMesh.position.set(o.x - textWidth / 2, o.y + info.height / 2 + textHeight + 2, self.defaultNodeDepth / 2 * -2);
      layer.plane.add(textMesh);
      layer.node[info.id].textMesh = textMesh;
      return textMesh;
    };

    Universe.prototype.resize = function() {
      return THREEx.ContainerResize(this.$container[0], this.renderer, this.camera);
    };

    Universe.prototype.initThree = function() {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.sceneWidth, this.sceneHeight);
      this.$container.append(this.renderer.domElement);
      return this.renderer.setClearColorHex(0x000000, 1.0);
    };

    Universe.prototype.loadTexture = function(path) {
      var b64_data, new_image, texture;
      if (typeof passthrough_vars !== 'undefined' && passthrough_vars.offline_mode) {
        b64_data = $('img[data-src="' + path + '"]').attr('src');
        new_image = document.createElement('img');
        texture = new THREE.Texture(new_image);
        new_image.onload = function() {
          return texture.needsUpdate = true;
        };
        new_image.src = b64_data;
        return texture;
      }
      return THREE.ImageUtils.loadTexture(path);
    };

    Universe.prototype.initSkybox = function() {
      var fragmentShader, geometry, material, skyBox, uniforms, vertexShader;
      geometry = new THREE.SphereGeometry(3000, 60, 40);
      uniforms = {
        texture: {
          type: 't',
          value: this.loadTexture("images/skybox.jpg")
        }
      };
      vertexShader = "varying vec2 vUV;\nvarying float vDensity;\nvarying float vDiff;\nvoid main() {\n	vUV = uv;\n	vec4 pos = vec4(position, 1.0);\n	gl_Position = projectionMatrix * modelViewMatrix * pos;\n}";
      fragmentShader = "uniform sampler2D texture;\nvarying vec2 vUV;\nvoid main() {\n    vec4 sample = texture2D(texture, vUV);\n    gl_FragColor = vec4(sample.xyz, sample.w);\n}";
      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      });
      skyBox = new THREE.Mesh(geometry, material);
      skyBox.scale.set(-1, 1, 1);
      skyBox.eulerOrder = 'XZY';
      skyBox.renderDepth = 1000.0;
      return this.scene.add(skyBox);
    };

    Universe.prototype.initCamera = function() {
      this.camera = new THREE.PerspectiveCamera(30, this.sceneWidth / this.sceneHeight, 0.1, 10000);
      this.camera.rotation.x = Math.PI / 2;
      this.camera.position.set(0, 800, this.defaultLayerWidth);
      this.camera.lookAt(this.scene.position);
      return this.scene.add(this.camera);
    };

    Universe.prototype.initScene = function() {
      return this.scene = new THREE.Scene;
    };

    Universe.prototype.initLight = function() {
      var baseNum, i, light, _i;
      light = [];
      for (i = _i = 0; _i <= 2; i = ++_i) {
        light.push(new THREE.SpotLight(0x999999, 1.2));
        this.scene.add(light[i]);
      }
      baseNum = 1000;
      light[0].position.set(baseNum, baseNum, baseNum);
      return light[2].position.set(baseNum * -1, baseNum, baseNum * -1);
    };

    Universe.prototype.render = function() {
      return this.renderer.render(this.scene, this.camera);
    };

    Universe.prototype.drawText = function(layer, text) {
      var materialArray, materialFront, materialSide, textGeom, textHeight, textMaterial, textMesh, textWidth;
      materialFront = new THREE.MeshBasicMaterial({
        color: 0xffffff
      });
      materialSide = new THREE.MeshBasicMaterial({
        color: 0x000088
      });
      materialArray = [materialFront, materialSide];
      textGeom = new THREE.TextGeometry(text, {
        size: 30,
        height: 4,
        curveSegments: 3,
        font: "lisu",
        weight: "normal",
        style: "normal",
        extrudeMaterial: 1
      });
      textMaterial = new THREE.MeshFaceMaterial(materialArray);
      textMesh = new THREE.Mesh(textGeom, textMaterial);
      textGeom.computeBoundingBox();
      textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
      textHeight = textGeom.boundingBox.max.y - textGeom.boundingBox.min.y;
      textMesh.rotation.x = Math.PI / 2 * -1;
      textMesh.position.set(this.defaultLayerWidth / 2 - textWidth, this.defaultLayerHeight / 2 - textHeight, 0);
      layer.add(textMesh);
      return textMesh;
    };

    Universe.prototype.addLayer = function(option) {
      var layer, mateOption, plane, str, textMesh;
      if (option == null) {
        option = {};
      }
      option.node = option.node ? option.node : [];
      option.width = option.width ? option.width : this.defaultLayerWidth;
      option.height = option.height ? option.height : this.defaultLayerHeight;
      option.planeQuality = option.planeQuality ? option.planeQuality : 10;
      mateOption = {
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7,
        color: 0xCCCCCC
      };
      option.material = option.material ? option.material : new THREE.MeshLambertMaterial(mateOption);
      plane = new THREE.Mesh(new THREE.PlaneGeometry(option.width, option.height, option.planeQuality, option.planeQuality), option.material);
      plane.receiveShadow = true;
      plane.rotation.x = Math.PI / 2;
      plane.position.x = 0;
      plane.position.z = 0;
      plane.position.y = 0;
      this.scene.add(plane);
      str = "图层" + (this.layers.length + 1);
      textMesh = this.drawText(plane, str);
      layer = {
        plane: plane,
        textMesh: textMesh
      };
      this.layers.push(layer);
      this.converPosition(option.graphWidth, option.graphHeight, option);
      this.drawNode(layer, option.nodes);
      this.drawLine(plane, option.edges);
      this.autoLayoutLayer();
      return this.render();
    };

    Universe.prototype.autoLayoutLayer = function() {
      var fn, i, item, self, startNum, _i, _len, _ref, _results;
      self = this;
      startNum = (self.layers.length - 1) * self.margin / 2 * -1;
      fn = function(item, i) {
        return item.plane.position.y = startNum + i * self.margin;
      };
      _ref = self.layers;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        _results.push(fn(item, i));
      }
      return _results;
    };


    /*
    	开启鼠标控制
       如果不开启，则无法用鼠标旋转摄像机角度与滚轮退远近
     */

    Universe.prototype.enableScrollWheelZoom = function() {
      var self;
      self = this;
      this.orbitControls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.orbitControls.damping = 0.2;
      this.orbitControls.addEventListener('change', function() {
        return self.render();
      });
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.bottom = '0px';
      this.stats.domElement.style.zIndex = 100;
      return this.$container.append(this.stats.domElement);
    };

    Universe.prototype.animate = function() {
      var fn, self;
      self = this;
      fn = function() {
        requestAnimationFrame(fn);
        self.orbitControls.update();
        self.stats.update();
        self.render();
        return self.updateBallAnimation();
      };
      return fn();
    };

    Universe.prototype.getPointsTween = function(points) {
      var i, item, ret, step, twoPoints, _i, _len;
      step = 2;
      ret = [];
      twoPoints = function(source, target) {
        var fn, item, steps, _i, _results;
        steps = Math.max(Math.abs(source.x - target.x), Math.abs(source.y - target.y), Math.abs(source.z - target.z)) / step;
        fn = function(item) {
          var o;
          o = {};
          if (source.x > target.x) {
            o.x = source.x - Math.abs(source.x - target.x) / steps * item;
          } else {
            o.x = source.x + Math.abs(source.x - target.x) / steps * item;
          }
          if (source.y > target.y) {
            o.y = source.y - Math.abs(source.y - target.y) / steps * item;
          } else {
            o.y = source.y + Math.abs(source.y - target.y) / steps * item;
          }
          if (source.z > target.z) {
            o.z = source.z - Math.abs(source.z - target.z) / steps * item;
          } else {
            o.z = source.z + Math.abs(source.z - target.z) / steps * item;
          }
          return ret.push(o);
        };
        _results = [];
        for (item = _i = 1; 1 <= steps ? _i <= steps : _i >= steps; item = 1 <= steps ? ++_i : --_i) {
          _results.push(fn(item));
        }
        return _results;
      };
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        item = points[i];
        if (!!points[i + 1]) {
          twoPoints(item, points[i + 1]);
        }
      }
      return ret;
    };

    Universe.prototype.crateLineBallAnimation = function(points) {
      var geometry, pathPoints, rectMesh, self;
      self = this;
      geometry = new THREE.SphereGeometry(3, 100, 50);
      geometry.computeTangents();
      rectMesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
        color: 0xffffff
      }));
      self.scene.add(rectMesh);
      pathPoints = self.getPointsTween(points);
      rectMesh.position.set(points[0].x, points[0].y, points[0].z);
      return self.ballAnimationQueue.push({
        ball: rectMesh,
        points: points,
        animatePoints: pathPoints,
        back: []
      });
    };

    Universe.prototype.updateBallAnimation = function() {
      var fn, item, self, _i, _len, _ref, _results;
      self = this;
      fn = function(item) {
        var point;
        if (item.animatePoints.length === 0) {
          item.animatePoints = item.back;
          item.back = [];
        }
        point = item.animatePoints.shift();
        item.back.push(point);
        return item.ball.position.set(point.x, point.y, point.z);
      };
      _ref = self.ballAnimationQueue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(fn(item));
      }
      return _results;
    };

    Universe.prototype.getNodeById = function(id) {
      var fn, item, ret, self, _i, _len, _ref;
      self = this;
      ret = null;
      fn = function(nodes) {
        var cfn, index, _results;
        cfn = function(node) {
          if (node.info.id === id) {
            return ret = node;
          }
        };
        _results = [];
        for (index in nodes) {
          _results.push(cfn(nodes[index]));
        }
        return _results;
      };
      _ref = self.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        fn(item.node);
      }
      return ret;
    };

    Universe.prototype.getNodeAbsolutePosition = function(node) {
      var o;
      o = {};
      o.x = node.parent.position.x + node.position.x;
      o.y = node.parent.position.y;
      o.z = node.parent.position.z + node.position.y;
      return o;
    };

    Universe.prototype.getNodeBetweenPoints = function(source, target) {
      var middlePoint, points;
      middlePoint = target.y > source.y ? source.y + (target.y - source.y) / 2 : target.y + (source.y - target.y) / 2;
      points = [];
      points.push(new THREE.Vector3(source.x, source.y, source.z));
      points.push(new THREE.Vector3(source.x, middlePoint, source.z));
      points.push(new THREE.Vector3(target.x, middlePoint, source.z));
      points.push(new THREE.Vector3(target.x, middlePoint, target.z));
      points.push(new THREE.Vector3(target.x, target.y, target.z));
      return points;
    };

    Universe.prototype.drawLayerLine = function(data) {
      var fn1, item, self, _i, _len, _results;
      self = this;
      fn1 = function(info) {
        var line, lineGeometry, lineMaterial, points, source, sourcePosition, target, targetPosition;
        source = self.getNodeById(info.source);
        target = self.getNodeById(info.target);
        if (source && target) {
          sourcePosition = self.getNodeAbsolutePosition(source.cube);
          targetPosition = self.getNodeAbsolutePosition(target.cube);
          points = self.getNodeBetweenPoints(sourcePosition, targetPosition);
          lineGeometry = new THREE.Geometry;
          lineGeometry.vertices = points;
          lineMaterial = new THREE.LineBasicMaterial({
            color: 0xFFFFFF,
            linecap: 'round'
          });
          lineGeometry.computeLineDistances(points);
          line = new THREE.Line(lineGeometry, lineMaterial);
          self.crateLineBallAnimation(points);
          return self.scene.add(line);
        }
      };
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        _results.push(fn1(item));
      }
      return _results;
    };

    Universe.prototype.getNodeSize = function(mesh) {
      var box, s;
      box = new THREE.Box3().setFromObject(mesh);
      s = {};
      s.x = box.max.x - box.min.x;
      s.y = box.max.y - box.min.y;
      s.z = box.max.z - box.min.z;
      box = null;
      return s;
    };

    return Universe;

  })();

  window.Universe = Universe;

}).call(this);

//# sourceMappingURL=Universe.js.map
